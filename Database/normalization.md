## 정규화
- 이상 현상이 발생하지 않도록, 릴레이션을 관련 있는 속성들로만 구성하기 위해 릴레이션을 분해하는 과정
- **함수적 종속성**을 판단하여 정규화를 수행함

### 정규화의 원칙

1. 정보의 무손실 표현 -> 하나의 스키마를 다른 스키마로 변환할 때 정보의 손실이 있어서는 안된다
2. 분리의 원칙 -> 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다
3. 데이터의 중복성이 감소되어야 한다

### 함수적 종속성(FD : Functional Dependency)
- 속성들 간의 관련성
- 함수 종속성을 이용하여, 릴레이션을 연관성이 있는 속성들로만 구성되도록 분해하여 이상 현상이 발생하지 않는 바람직한
릴레이션으로 만들어 나가는 과정이 정규화

### 함수 종속
- X가 Y를 함수적으로 결정한다
  - 릴레이션 내의 모든 튜플을 대상으로 하나의 X값에 대한 Y값이 항상 하나임
  - X와 Y는 하나의 릴레이션을 구성하는 속성들의 부분 집합
  - **Y가 X에 함수적으로 종속되어 있다**와 같은 의미
  - X -> Y로 표현(X는 결정자, Y는 종속자)

![image](https://user-images.githubusercontent.com/67304980/131967289-3e5b95c7-bbe0-4e36-9fa6-030d7c5c93b5.png)

#### 함수 종속 관계 판단 예 1

![image](https://user-images.githubusercontent.com/67304980/131967410-13cb4975-e406-4bed-a09b-61019d8c4e56.png)

고객아이디에 따라 고객이름을 결정한다, 고객아이디에 따라 등급을 결정한다.

고객이름이 등급을 결정한다(안됨) -> 만약 동명이인일 경우 이름이 같아도(X) 두 가지 등급(Y)이 존재할 수 있다.
하나의 X가 두 개의 Y값을 가지므로 안된다. 고객아이디가 PK라 중복이 안되므로 위의 관계가 가능하다

함수 종속 다이어그램 : 함수 종속 관계를 도식화하여 표현한 것

![image](https://user-images.githubusercontent.com/67304980/131968008-f6d67b62-61b3-4ed5-a5dc-f09ec33da3f6.png)

앞에 있는 고객아이디는 결정자, 화살표 표시 받는 고객이름, 등급은 종속자이다

#### 함수 종속 관계 판단 시 유의 사항
- 속성 자체의 특성과 의미를 기반으로 함수 종속성을 판단해야 한다
  - 속성 값은 계속 변할 수 있으므로 현재 릴레이션에 포함된 속성 값만으로 판단하면 안된다
  - 예를 들어 함수 종속 관계 판단 예 1 처럼 현재 상태로는 고객이름으로 등급을 판단할 수 있지만, 동명이인이 들어오게 되면
  고객이름으로 등급을 판단할 수 없다
  - 일반적으로 기본키와 후보키는 릴레이션의 다른 모든 속성들을 함수적으로 결정한다
  - 기본키나 후보키가 아니어도 다른 속성 값을 유일하게 결정하는 속성은 함수 종속 관계에서 결정자가 될 수 있다
  
#### 함수 종속 관계 판단 에 2

![image](https://user-images.githubusercontent.com/67304980/131970992-38d35516-dcc9-44a5-856d-4a7f8b7dae67.png)

고객아이디가 고객이름을 결정하고, '고객아이디 + 이벤트번호'가 당첨여부를 결정한다

![image](https://user-images.githubusercontent.com/67304980/131971300-3388f4c8-ab88-455c-9149-18fa6e014884.png)

#### 완전 함수 종속(FFD : Full Functional Dependency)
- 릴레이션에서 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어 있지만, 속성 집합 X의 전체가 아닌 일부분에는 종속되지
않음을 의미
- **일반적으로 함수 종속은 완전 함수 종속을 의미함**
- 예) 당첨여부는 {고객아이디, 이벤트번호}에 완전 함수 종속됨

#### 부분 함수 종속(PFD : Partial Functional Dependency)
- 릴레이션에서 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미
- 예) 고객이름은 {고객아이디, 이벤트번호}에 부분 함수 종속됨 -> 고객아이디만으로도 고객이름을 파악할 수 있음

#### 이행적 함수 종속(transitive FD)
- 릴레이션을 구성하는 세 개의 속성 집합 X,Y,Z에 대해 함수 종속 관계 X->Y와 Y->Z가 존재하면 논리적으로 X->Z가 성립되는데,
이것을 Z가 X에 이행적으로 함수 종속되었다고 한다

![image](https://user-images.githubusercontent.com/67304980/131972055-74f99fe1-9aed-41bb-9567-2c51b490ca45.png)

예를 들어 X가 고객 id, Y가 등급, Z가 할인율이라면 고객아이디가 등급을 결정하고등급이 할인율을 결정한다. 따라서 고객아이디에
따라 할인율이 결정되어 있다고 볼 수 있다

#### 고려할 필요가 없는 함수 종속 관계
- 결정자와 종속자가 같거나, 결정자가 종속자를 포함하는 것처럼 당연한 함수 종속 관계는 고려하지 않음

![image](https://user-images.githubusercontent.com/67304980/131972496-3959bb80-fb05-4360-b8a0-f2f215caaf93.png)

### 정규화(normalization)
- 함수 종속성을 이용해 릴레이션을 연관성이 있는 속성들로만 구성되도록 분해해서 이상 현상이 발생하지 않는 바람직한 릴레이션으로
만들어 가는 과정
- 정규화를 통해 릴레이션은 **무손실 분해**되어야 한다
  - 릴레이션은 의미적으로 동등한 릴레이션들로 분해되어야 하고 분해로 인한 정보의 손실이 발생하지 않아야 한다
  - 분해된 릴레이션들을 자연 조인하면 분해 전의 릴레이션으로 복원 가능해야 한다

### 정규형(NF : Normal Form)
- 릴레이션이 정규화된 정도
- 각 정규형마다 제약조건이 존재
  - 정규형의 차수가 높아질수록 요구되는 제약조건이 많아지고 엄격해진다
  - 정규형의 차수가 높아질수록 데이터 중복이 줄어 이상 현상이 발생하지 않는 바람직한 릴레이션이 된다
- 릴레이션의 특성을 고려하여 적합한 정규형을 선택

![image](https://user-images.githubusercontent.com/67304980/131973238-3572c484-6613-40da-84e1-c701d58f47ef.png)
![image](https://user-images.githubusercontent.com/67304980/131973265-5cbb5361-d17a-4d03-9226-82e8fac746e0.png)

### 제 1 정규형(1NF : First Normal Form)
- 릴레이션의 모든 속성이 더는 분해되지 않는 원자 값(atomic value)만 가지면 제 1 정규형을 만족함
- 제 1 정규형을 만족해야 관계 데이터베이스의 릴레이션이 될 자격이 있음

![image](https://user-images.githubusercontent.com/67304980/131975158-408522e7-e3f6-4b53-96d2-1ce1314d8ffc.png)

이벤트번호와 당첨여부에 다중 값을 포함한 경우가 있다. 속성의 값이 다중값을 가지므로 제 1정규형 제약조건을 만족하지 못한다

![image](https://user-images.githubusercontent.com/67304980/131975286-f46cd570-d992-4f5f-977c-63b799382220.png)

이렇게 각각의 속성값이 원자값으로만 구성되어 있으면 제 1정규형을 만족한다

![image](https://user-images.githubusercontent.com/67304980/131975493-a0f6c3a5-9e35-4f2d-a24f-51576f131b0a.png)

먼저 삽입이상이 발생할 수 있다. 고객아이디가 melon인 사람을 삽입하려 할 때, 이벤트에 참여하지 않았다면 이벤트번호에
null을 넣어야 하므로 삽입이상이 발생한다.
갱신이상은 만약 고객아이디가 apple인 사람의 등급을 vip로 변경한다고 할 때, 2개는 vip로 변경하고 하나는 갱신을 안한다면
동일한 고객아이디에 등급이 다르므로 갱신이상이 나타난다. 마지막으로 삭제이상은 만약 orange고객이 이벤트 참여 기록을
취소하고 싶다고 하면 이벤트번호와 당첨여부를 삭제해야 하는데 등급과 할인율과 같은 필요한 정보까지 삭제되는 삭제이상이
발생한다.

![image](https://user-images.githubusercontent.com/67304980/131975868-5e72410c-17b1-4340-b875-c530c512ddd8.png)

#### 이상 현상의 발생 이유
- 기본키인 {고객아이디, 이벤트번호}에 완전 함수 종속되지 못하고 일부분인 고객아이디에 종속되는 등급과 할인율 속성이 존재하기 때문

이를 해결하기 위해서는 부분 함수 종속이 제거되도록 이벤트참여 릴레이션을 분해

-> 분해된 릴레이션은 제 2정규형에 속하게 된다

### 제 2 정규형(2NF : Second Normal Form)

릴레이션이 제 1 정규형에 속하고, 기본키가 아닌 모든 속성이 기본기에 완전 함수 종속되면 제 2정규형을 만족

![image](https://user-images.githubusercontent.com/67304980/131999832-26c57c66-dc45-48c6-8d6c-00560511d4d8.png)
![image](https://user-images.githubusercontent.com/67304980/131999854-0c2aa9fc-fb69-45ca-8626-11274dda6a02.png)

(고객아이디, 이벤트번호)의 기본키에 따라 등급과 할인율이 결정되는 것이 아니라, 고객 아이디만으로 등급과 할인율이
결정되기 때문에 부분 함수 종속되었다고 할 수 있다

![image](https://user-images.githubusercontent.com/67304980/131999951-92ed4865-d946-4a28-aefa-133885b125ef.png)

이 릴레이션은 이상 현상이 발생할 수 있는데 구체적인 예를 살펴보자

![image](https://user-images.githubusercontent.com/67304980/131999995-f08bfde7-6484-42d9-83d7-a4d7a68499bf.png)

gold등급의 할인율을 15로 올릴때 일부만 올린다면 갱신이상이 발생한다
만약 banana를 지운다면 vip등급의 할인율이 20%라는 데이터도 삭제되게 된다.
새로운 bronze 등급과 할인율을 정했는데 해당 등급 고객이 없다면 삽입 불가로 인한 삽입이상이 발생한다.
이행적 종속 관계는 A->B, B->C일 때 A->C를 의미하는 것이다. 고객아이디가 등급을 결정하고,
등급이 할인율을 결정하는 이행적 함수 종속이 존재한다. 이러한 이행적 함수 종속이 제거되도록 고객 릴레이션을 분해한다.
분해한 릴레이션은 제 3 정규형에 속하게 된다.

### 제 3 정규형(3NF : Third Normal Form)

릴레이션이 제 2 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속되지 않으면 제 3 정규형 만족

![image](https://user-images.githubusercontent.com/67304980/132000628-a9e4fb0e-aa94-4a7c-9407-5ec037c2fb10.png)
![image](https://user-images.githubusercontent.com/67304980/132000657-f733bd49-9254-4a9d-8682-2c8fa52aeef5.png)

이렇게 고객 릴레이션과 고객등급 릴레이션으로 나누면 모두 제 3 정규형에 속하게 된다


## 데이터베이스 설계 프로세스
- ER 다이어그램을 릴레이션으로 변환을 통하여 생성
- 모든 속성(Attributes)을 포함하는 하나의 릴레이션 - Universal Relation
  - 정규화를 통해서 작은 테이블들로 분해된다
- ad hoc 디자인을 통해서 생성
  - 정규화를 통해서 테스트하고 좋은 디자인으로 변화

### ER 다이어그램과 Normalization
- ER 다이어그램이 모든 데이터를 잘 표현할 수 있게 설계되어 있다면 ER 다이어그램으로 생성된 테이블들은 추가적인 정규화 과정이 필요하지 않다
- 그러나 실제 디자인에서는 키 속성이 아닌 속성(Attribute)에서 시작하는 함수적 종속성(functional dependency)이 있을 수 있고 이런 문제들을 정규화를 통해서 분해 과정을 거친다
  - 예제) Employee (employee_id, name, department_name, building) { department_name } -> { building }

### Denormalization
- 정규화를 거쳐서 분해 된 테이블들을 조회할 때 분해되기 전 속성들을 볼 필요가 있다면 JOIN QUERY가 필요
  - 아래 예제에서 Book의 전체 데이터를 조회할 때 Book, Author, Genre 테이블의 join query가 필요
  - 만약 정규화 되기 전의 테이블이었다면 single table scan

![image](https://user-images.githubusercontent.com/67304980/137078332-f3258aef-aa18-465b-ad45-0582d34e4be0.png)

Denoralization의 특징을 정리하면 
- 업데이트가 거의 발생하지 않으며 조회 성능이 중요한 어플리케이션에서 사용
- 빠른 조회 성능 제공
- 중복 데이터 저장으로 인해 저장 공간이 더 필요하게 되고 update가 느려진다
- 어플리케이션에서 이상 현상 등이 발생하지 않게 추가적인 코딩이 필요

대안적인 방법으로 Materialized View가 있다. 특징을 정리하면 
- 필요한 속성들을 포함한 join query에 대한 materialized view을 생성한다
- 테이블 형태로 저장되기 때문에 denormalization과 같은 성능 제공
- 추가적인 저장 공간이 필요, view을 업데이트하는 cost가 필요
- 그러나 어플리케이션에서 이상 현상에 대한 에러 처리가 필요 없음
- Materialized View에 대해 더 알아보면
  > MView는 View이지만 일반 View는 논리적인 테이블이고 MView는 물리적으로 존재하는 테이블이다. 물리적으로 존재한다는 것은 Data가 일정 공간을 차지하고 있다는 것이다. MView는 어떤 결과를 뽑아 내는 쿼리가 너무 빈번하게 사용될 경우 쿼리 실행 시간 수행속도 향상을 위해서 여러 Aggregate View를 두어 미리 비용이 많이 드는 조인이나 Aggregate Operation을 처리하는 SQL을 위해 데이터베이스의 한 테이블로 저장하며, 그 테이블을 조회하도록 하는 것이다. 간단히 설명하면 대용량의 데이터를 SUM, MIN, MAX, AVG, COUNT 등 명령어를 사용해 너무 자주 조회하는 쿼리의 수행속도 향상을 위해 Query결과의 새로운 테이블을 생성해 놓는 방법이다. 그 View의 결과를 디스크에 저장해서 쿼리 속도를 향상시킨다. MView는 실행의 결과와 뷰 정의 모두 저장되고 실행 결과 행으로 만들어진 테이블은 일정 공간을 차지한다. View와의 가장 큰 차이점은 MView의 결과값은 물리적으로 존재하는 것이고 일반 View의 결과값은 물리적으로 존재하지 않는다. 즉 SELECT * FROM USER_SEGMENTS하면 MView는 나오지만 일반 View는 나오지 않는다. MView는 MView를 생성할 때의 쿼리로 물리적으로 이미 데이터가 생성되어 있기 때문에 조회 속도가 빠르다. 하지만 View는 단지 쿼리정보가 딕셔너리에 저장되어 있고 사용될때 그 SQL이 다시 실행되는 것이기 때문에 MView보다 느리다. MView로 생성된 결과값이 일반 View로 조회하는 Data의 결과값보다 훨씬 적은 Row를 조회하게 된다.


그렇다면 정규화 과정을 통해 발견 못하는 디자인 이슈들은? 
- 새로운 데이터가 추가될 때마다 컬럼 추가가 필요한 경우
- 새로운 데이터가 추가될 때마다 테이블 추가가 필요한 경우
- 예제)
  - Good design
    - Earings (company_id, year, earning)
  - Bad
    - Earning_2019 (company_id, earning), Earning_2020 (company_id, earning)
    - Earnings (company_id, earning_2019, earning_2020)

### 정규화와 반정규화 장단점

#### 정규화
- 장점
  - 데이터베이스 변경시 이상현상 제거
  - 저장 공간의 최소화 가능(테이블을 분해해서 중복 데이터가 저장되지 않도록 하고 필요한 테이블에만 최소의 데이터를 삽입)
  - 효과적인 검색 알고리즘 생성 가능(데이터베이스 중복이 없고 하나의 종속성이 하나의 릴레이션으로 포함되므로 테이블들을 잘 이용해 효과적인 SELECT 가능)

- 단점
  - 릴레이션 간의 JOIN연산 증가
  - 이로 인해 질의에 대한 응답 시간 저하

#### 반정규화

어느 정도의 데이터 중복이나 그로 인해 발생하는 데이터 갱신 비용은 감수하는 대신 **조인 횟수를 줄여** 한층 효율적인 쿼리를 날릴 수 있도록 하겠다는 것이다

- 장점
  - 빠른 데이터 조회 -> 조인 비용이 줄어들기 때문
  - 살펴볼 테이블이 줄어들기 때문에 데이터 조회 쿼리가 간단해짐 

- 단점
  - 데이터 갱신이나 삽입 비용이 높다
  - 데이터 갱신 또는 삽입 코드를 작성하기 어려워진다
  - 데이터 간의 일관성이 깨질 수 있다(이상현상 발생 가능)
  - 데이터를 중복하여 저장하므로 더 많은 저장 공간이 필요

#### [나의 정리]
> 정규화는 데이터베이스의 일관성을 해치는 이상현상을 방지하기 위해 테이블을 분해하는 과정이다. 일관성을 유지하며 데이터의 삽입, 수정, 삭제에 대해 연산이 이루어진 이후에도 일관성이 유지된다. 일관성이 보장되고 중복성이 제거된 데이터베이스에서 효율적인 검색 알고리즘을 쓴다면 오류 없이 원하는 데이터를 얻을 수 있다. 하지만 테이블이 분리되어 있으므로 여러 테이블에 대한 데이터를 얻으려 할 때 join을 사용해야 하는데, join을 쓰면 질의에 대한 응답 시간이 저하된다. 따라서 join을 이용하는 SELECT의 경우 속도가 느릴 수 있다. 이 속도를 향상시키기 위해 반정규화를 사용하여 탐색되는 테이블을 줄여 join사용을 줄일 수 있다. 하지만 반정규화를 과도하게 적용하면 데이터의 무결성이 깨질 수 있다. 또한 삽입, 수정, 삭제 시 이상 현상이 발생하고 더 많은 데이터 저장 공간이 필요하게 된다. 따라서 어느 정도 정규화를 수행한 뒤 SELECT 수행을 빠르게 하기 위해 View나 MView, 인덱스를 통한 조회 시간 단축을 고려하는 것이 좋다











