## 컴퓨터 시스템의 동작 원리

### 컴퓨터 시스템의 구조
- 컴퓨터 내부장치 : CPU, 메모리
- 컴퓨터 외부장치 : CPU, 메모리 외 나머지


![a](https://user-images.githubusercontent.com/67304980/128183762-993a4835-84db-4c7e-b54d-0b63b04e2a34.JPG)

- 입력은 컴퓨터 내부로 데이터가 들어오고 출력은 컴퓨터 외부로 데이터가 나가는 것으로 컴퓨터 외부장치 = 입출력 장치

### CPU 연산과 I/O 연산
- 컴퓨터 연산 = CPU가 연산
- 입출력 장치의 I/O가 연산 = 입출력 컨트롤러가 연산
- 로컬버퍼 : 각 입출력 장치의 컨트롤러가 입출력된 데이터를 임시로 저장하는 작은 메모리
  - 디스크나 키보드 등에서 데이터를 읽어오는 경우
    - 컨트롤러가 장치로부터 데이터를 받아 로컬버퍼에 저장한다
    - 컨트롤러가 CPU의 서비스가 필요할 때 CPU에게 인터럽트 신호 발생시킨다(인터럽트 라인이라는 통로 이용)
- 프로그램이 디스크의 데이터 요청 -> 디스크 컨트롤러가 로컬버퍼로 데이터 읽어서 가져옴 -> 컨트롤러가 CPU에게 인터럽트 발생시킴 -> CPU는 인터럽트를 감지하고 관련 업무 수행

### 인터럽트의 일반적 기능
- 부팅이 끝나고 나면 운영체제는 메모리에 상주한다. 그리고 사건(event)를 기다리며 대기하는 상태이다
- 운영체제 커널에는 인터럽트가 들어왔을 때 해야 할 일이 다 프로그래밍되어 그 코드가 보관되어 있음
- 인터럽트에는 하드웨어 인터럽트, 소프트웨어 인터럽트가 있다
  - 하드웨어 인터럽트 : 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅
    - 만약 우리가 마우스를 움직이면 전기 신호가 발생하고 CPU의 인터럽트 라인으로 연결되고 CPU는 마우스의 event를 인식한다. 그러면 CPU는 현재 하는 일을 중지하고 OS안에 있는 마우스 인터럽트 서비스 루틴(ISR)으로 이동한다. 여기에는 마우스를 움직이면 커서를 옮기는 루틴이 들어있다. 따라서 우리가 마우스를 움직이면 커서가 움직이게 된다. 키보드의 경우도 우리가 어떤 키를 누르면 전기신호가 전달되고 CPU가 OS의 키보드 인터럽트 루틴을 실행시켜서 결국 키보드를 누르면 그 값이 입력되는 것이다
  - 소프트웨어 인터럽트 : 소프트웨어가 인터럽트 라인을 세팅
    - int, swi 명령어가 입력되면 인터럽트가 작용되어 OS내의 특정 코드가 실행(ISR)된다. ISR 종료 후 사용자 프로그램으로 돌아간다.
- 인터럽트 벡터 : 인터럽트 종류마다 번호를 정해놓은 자료구조. 여기서 번호는 해야할일이 적힌 코드의 위치를 가리킴
- 인터럽트 처리루틴, 인터럽트 핸들러 : 실제 처리할 코드가 정의된 곳
- 보통 인터럽트라하면 하드웨어 인터럽트를 말한다. 그래서 소프트웨어 인터럽트를 구분하기 위해 트랩(trap)이라는 용어로 주로 불린다
  - 소프트웨어 인터럽트의 예
  - 예외상황(exception)
    - 0으로 나누거나, 자신의 메모리 바깥에 접근하려고 할 때 이에 대한 처리를 위해 발생시키는 인터럽트. OS안에 0으로 나눌 때의 ISR이 들어 있고 여기에서는 강제로 종료시키도록 하고 있다. 이런 내부 인터럽트에 의해 OS안에 ISR이 동작한다. 사용자가 갑자기 하드 디스크를 읽으려고 하면, OS안에 하드 디스크를 읽는 ISR이 실행된다. ISR이 작업을 마치면 OS는 대기상태가 되고 작업은 다시 사용자 프로그램으로 돌아오게 된다.
  - 시스템 콜(system call)
    - 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법
    - 사용자 프로그램이 CPU를 사용하고 싶다고 CPU를 제어하는 코드를 다 짤 수 없어서 인터럽트 라인 세팅을 통해 CPU 제어권을 넘겨 실행하게 한다
    - 사용자는 이미 존재하는 커널의 코드를 호출해서 처리한다
  - 시스템 콜이나 예외상황은 모두 사용자 프로세스로부터 CPU의 제어권이 운영체제에 이양되어 처리되는데, 이 과정에서 프로그램 코드가 직접 인터럽트 라인을 세팅하는 명령을 실행하여 인터럽트를 발생시킨 후 제어권이 넘어가게 되므로 이들도 넓은 의미에서 인터럽트의 범주에 포함시킨다

### 인터럽트 핸들링
- 인터럽트 핸들링 : 인터럽트가 발생한 경우 처리해야 할 일의 절차
- 인터럽트가 발생되면 일단 현재 상태를 저장
  - 실행 중인 명령의 메모리 주소를 포함해 몇 가지 부가적인 정보(=현재 상태)를 저장
  - CPU는 명령이 실행될 때 레지스터(CPU 내부에 있는 임시 기억장치)의 데이터를 읽고 쓰면서 작업하는데 인터럽트를 처리하면 이 명령어가 다 사라지기 때문에 PCB 사용
- PCB(Process Control Block, 프로세스 제어블록)
  - 현재 시스템 내에서 실행되는 프로그램들을 관리하기 위해 운영체제 내에 있는 자료구조
  - PCB는 각각의 프로그램마다 하나씩 존재하며 해당 프로그램의 어느 부분이 실행중이었는지 저장
  - 저장 되는 값들 : 프로그램이 실행 중이던 코드의 메모리 주소와 레지스터 값, 하드웨어 상태 등
- 인터럽트가 발생했을때 PCB의 역할
  - 프로그램이 실행되던 중 인터럽트가 발생하면 그 프로그램의 상태는 PC에 저장한 후 CPU의 제어권이 인터럽트 처리루틴으로 넘어간다
  - 인터럽트 처리가 끝나면 PCB로부터 저장된 상태를 CPU로 복원해 직전 위치부터 실행한다
- 오늘날 운영체제는 인터럽트가 발생할 때에만 실행된다
  - CPU가 온전히 사용자 프로그램에 의해서만 사용되다가 인터럽트가 발생해야 운영체제가 CPU를 사용한다
  - 사용자 프로그램이 원하는 만큼 CPU르 점유할 수 있게 된다

### 입출력 구조
- 입출력 : 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고받는 것
- 동기식 입출력 : 입출력 작업이 완료될때까지 기다렸다가 후속작업을 하는 방식
  - CPU는 동기식 입출력이 끝날때까지 아무 작업도 못하고 기다려야돼서 자원의 낭비가 발생함
  - 이때 해당 프로그램에는 CPU를 할당하지 않고 다른 프로그램에 CPU를 할당해서 자원의 낭비를 막는데 할당되지 못하는 상태를 봉쇄 상태(blocked state)라고 한다
- 정리 : 프로그램 A에서 CPU가 작업중 -> 디스크에서 데이터를 불러와야 함 -> 인터럽트 발생 -> CPU는 프로그램 A에서 손을 떼고 다른 프로그램을 처리하게 된다 -> 프로그램 A에서 필요한 데이터를 다 불러올때까지 프로그램 A는 봉쇄 상태(blocked state)가 된다.
- 비동기식 입출력 : 입출력 작업이 완료될때까지 기다리지 않고서도 할수 있는일들을 하는것

### DMA(Direct Memory Access)
- 원칙적으로 메모리는 CPU에 의해서만 접근 가능
- CPU는 로컬버퍼와 메모리 사이에 데이터를 옮긴다
- 입출력장치가 메모리 접근을 원할 때마다 CPU에게 인터럽트를 발생시키면 CPU가 할일이 너무 많아진다
- 이를 해결해 주는 장치가 DMA(Direct Memory Access)이다
  - DMA는 일종의 컨트롤러
  - DMA가 로컬버퍼에서 메모리로 읽어오는 일을 대행함
  - DMA는 바이트 단위가 아닌 블록단위로 일을 함
![dma](https://user-images.githubusercontent.com/67304980/128346566-19e6604f-c000-4ecc-b8ec-6256b4d5adc3.JPG)
  - CPU의 개입 없이 I/O 장치와 기억장치 사이의 데이터를 전송

### 저장장치의 구조
- 저장장치 = 주기억장치(메모리) + 보조기억장치
- 보조기억장치의 용도
  - 파일 시스템용
    - 전원이 나가도 유지되어야 하는 정보 저장용
  - 스왑 영역용
    - 스왑 영역 : 메모리의 연장 공간
    - 메모리는 비싸기 때문에 메모리가 부족한 상황이 흔하게 발생해서 당장 필요하지 않은 부분을 스왑 영역에 내려놓게 된다 -> 스왑 아웃이라고 함

### 저장장치의 계층 구조
![저장장치계층](https://user-images.githubusercontent.com/67304980/128347012-e376d8cb-90d1-449c-afc6-59ac93a499c7.JPG)
- 위로 갈수록 비싸고 빠르다
- 정말 필요한 정보일수록 위로 가고 그렇지 않은 부분은 밑에 보관하는 식으로 자원을 효율적이고 빠르게 사용한다
- 캐싱 기법 : 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적 기법
  - 느린 저장장치에 있는 내용 중 당장 사용되거나 빈번히 사용된 정보를 빠른 저장장치에 선별적으로 저장함으로써 두 저장장치 사이의 속도를 완충시킨다
  - 예를 들어 프로그램의 코드 중에는 많은 횟수 동안 반복되는 코드와, 한번 수행되고 끝나는 부분이 있을 수 있다. 이러한 경우 반복되는 코드를 빠른 저장장치에 올려놓으면 적은 저장공간만으로도 전체 시스템의 평균적인 성능을 향상시킬 수 있다. 이러한 캐싱 기법을 컴퓨터 시스템 내의 다양한 저장장치 계층에서 활용함으로써 적은 용량의 상위 저장장치만으로도 대부분의 경우 빠른 수행 속도의 성능을 얻어낼 수 있게 된다

### 하드웨어의 보안
- 운영체제는 멀티 프로그래밍 환경으로 여러 프로그램을 실행할 수 있다
- 각 프로그램이 다른 프로그램의 실행을 방해하거나 충돌을 일으킬 수 있다
- 이를 막기 위해 운영체제는 커널 모드(kernel mode, system mode)와 사용자 모드(user mode)가 있다

커널모드
- 중요한 정보에 접근하여 연산하는 경우는 커널모드에서만 실행된다
- 모든 종류의 명령을 다 실행할 수 있다
- 하지만 사용자 프로그램이 CPU를 갖고 있는 동안은 운영체제가 이를 감시할 수가 없다(CPU를 차지하고 있지 않기 때문)
- 이 상황을 하드웨어적으로 해결 -> 모드 비트
  - mode bit = 0 -> 커널 모드
  - mode bit = 1 -> 사용자 모드
- 운영체제에서 사용자 프로그램으로 CPU의 권한을 넘겨줄 때 mode bit를 1로 설정해서 넘겨준다. CPU는 보안과 관련된 명령을 수행하기 전에는 항상 모드비트를 조사해 그 값이 0으로 세팅된 경우에만 실행한다
- 파일 입출력의 경우 사용자가 다른 사용자의 파일에 접근하면 안된다. 그래서 커널모드로만 입출력을 할 수 있다. 운영체제가 입출력을 실행하기 전에 올바른 입출력인지 판단하고 실행하기 때문에 보안 유지 가능하다.
    
이를 이중 모드라고도 한다. 일반 프로그램 실행 과정을 살펴보자. 첫째로 프로그램이 메모리에 적재된다. 이때는 사용자 모드인데 사용자가 키보드, 마우스 작업을 하면 시스템모드로 바뀌고 ISR이 실행된다. 그 작업이 마무리 되면 다시 사용자 모드로 전환된다. 이후 또 다시 모니터, 디스크, 프린터 등의 작업이 있다면 시스템 모드로 바뀌고 ISR이 실행된다. 작업이 종료되면 다시 사용자 모드로 전환된다. 이러한 이중모드는 "보호"와 관련이 있다.
- 입출력장치 보호
  - 예를 들어 한 사람이 프린터를 사용하고 있는데 다른 사용자가 프린터에 reset신호를 보낸다던지, 나도 사용하겠다고 신호를 보낸다면 안된다. 혹은 하드디스크에 여러 사람의 파일이 들어 있는데, 특정 사용자가 다른 사용자의 파일을 보면 안된다. 이처럼 입출력장치들은 보호를 받아야 한다.

  - 해결법 : 입출력 명령을 특권명령으로 지정한다(in,out명령어). 즉 입출력을 하려면 운영체제에게 요청(software interrupt)하고(system mode로 전환), 운영체제가 입출력을 대행해주고 마치고 다시 user mode로 돌아온다. 만약 올바른 요청이 아니라면 운영체제가 거부할 수 있다. (모든 애플리케이션은 하드웨어에 직접 접근 불가하다. 하드웨어를 os가 감싸고 있기 때문에 애플리케이션은 os에 부탁을 하여 하드웨어에 접근할 수 있다.)

- 메모리 보호
  - 다른 사용자의 메모리나 운영체제 영역 메모리에 접근할 수 있는 문제가 발생할 수 있다. 이는 다른 사용자 정보/프로그램/운영체제에 대한 해킹이 발생할 수 있다. 그래서 MMU(Memory Management Unit)을 두어 다른 메모리 영역의 침범을 감시하도록 한다. MMU설정은 특권명령으로 운영체제만 바꿀 수 있다

- CPU 보호
  - while(n=1)... -> c 프로그램에서 이 코드는 무한루프를 돈다. 따라서 다른 사용자의 프로그램은 실행이 불가능하게 된다. 이러한 상황을 해결하는 방법은 Timer를 두어 일정 시간 경과 시 타이머 인터럽트를 걸어 OS안에 ISR가 실행되도록 한다. ISR에는 오랜 기간 특정 프로그램에 묶여있다면 다른 프로그램으로 강제 전환되도록 하는 코드가 실행된다.




























