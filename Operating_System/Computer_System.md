## 컴퓨터 시스템의 동작 원리

### 컴퓨터 시스템의 구조
- 컴퓨터 내부장치 : CPU, 메모리
- 컴퓨터 외부장치 : CPU, 메모리 외 나머지


![image](https://user-images.githubusercontent.com/67304980/140099406-ece9af42-e1b6-410c-a492-0dad43689866.png)


- 입력은 컴퓨터 내부로 데이터가 들어오고 출력은 컴퓨터 외부로 데이터가 나가는 것으로 컴퓨터 외부장치 = 입출력 장치
- 레지스터는 CPU안에 있고, 메모리보다 더 빠르면서 정보를 저장하는 공간이다. 레지스터에는 PC(program counter)가 있고 여기에 다음에 수행할 메모리 주소가 담겨있다.
- 모드 비트는 CPU안에 있고, CPU에서 실행되는 것이 운영체제인지 사용자 프로그램인지 구분해 주는 것이다. 모드 비트가 0이면 커널 모드이고, OS 코드를 수행 중임을 표현한다. 모드 비트가 1이면 사용자 프로그램을 수행 중임을 표현한다. 만약 모드 비트가 1인 상태에서 사용자 프로그램이 메모리에 접근하거나, I/O에 접근한다면 모드 비트가 1이므로 instruction 실행이 안되도록 하드웨어를 구현한 것이다. 운영체제가 실행되고 나서 사용자 프로그램에게 CPU 제어권을 넘길 때 모드 비트를 1로 바꾸고 넘겨주는 것이다.
- 인터럽트 라인은 CPU에 붙어 있고, CPU는 원래 메모리에 있는 instruction만 실행하지만 사용자 프로그램이 키보드 입력, 디스크 읽기를 요구하는 경우, 즉 I/O device 접근할 때 사용자 프로그램이 직접 디스크에 접근하는 것이 아니라 CPU제어권을 운영체제로 넘기고, CPU가 디스크 컨트롤러에게 디스크의 어느 부분을 읽으라는 명령을 한다. 디스크는 컨트롤러의 지시를 받아 읽어서 데이터를 로컬 버퍼에 저장한다. 디스크 읽기는 상당히 느린 과정이므로, 그 사이 CPU는 메모리에서 다른 instruction들을 수행한다. 또한 만약 무한루프에 걸릴 경우 CPU는 다른 프로세스에 할당되지 못하므로 timer의 제약 시간에 도달하게 된다. 그러면 timer가 CPU에 인터럽트를 건다. CPU는 하나의 instruction을 수행하고 인터럽트 라인을 체크하고 그 다음 instruction으로 넘어간다. 인터럽트 라인에 인터럽트가 들어와있다면 CPU의 제어권이 사용자 프로그램으로부터 운영체제로 넘어간다. 운영체제가 CPU를 얻으면 timer에 다시 값을 세팅해서 다음 사용자 프로그램에게 CPU 제어권을 넘긴다.
- 타이머는 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킨다. 타이머 값이 0이 되면 타이머 인터럽트 발생, CPU를 특정 프로그램이 독점하는 것으로부터 보호
- I/O device controller : 해당 I/O 장치유형을 관리하는 일종의 작은 CPU, 제어 정보를 위해 control register, status register를 가지고 local buffer를 가진다(일종의 data register). I/O는 실제 device와 local buffer 사이에서 일어난다. Device controller는 I/O가 끝났을 경우 인터럽트로 CPU에 사실을 알린다
- DMA controller(Direct Memory Access 컨트롤러) : 직접 메모리에 접근하는 컨트롤러이다. 원래는 메모리에 접근하는 것은 CPU뿐이지만, DMA 컨트롤러도 접근할 수 있다. 메모리 컨트롤러는 CPU와 DMA 컨트롤러가 동시 접근하는 것을 조율한다. DMA 컨트롤러는 I/O에서 너무 많이 발생하는 인터럽트 때문에 오버헤드가 큰 문제를 해결하기 위해 로컬버퍼에 들어오는 내용이 작업이 끝났으면 DMA가 로컬버퍼의 내용을 메모리에 복사해주는 역할을 CPU 대신 수행한다. 그러고 나서 CPU에 작업 수행이 완료되었음을 알려준다. CPU입장에서는 인터럽트의 수가 줄어들게 된다.

- device driver : OS 코드 중 각 장치별 처리루틴 -> software
- device controller : 각 장치를 통제하는 작은 CPU -> hardware

### CPU 연산과 I/O 연산
- 컴퓨터 연산 = CPU가 연산
- 입출력 장치의 I/O가 연산 = 입출력 컨트롤러가 연산. 예를 들어 디스크에서 헤드가 어떻게 움직이고 어떻게 읽을지 내부를 통제하는 것은 CPU가 아니라 디스크 컨트롤러가 수행하는 것이다. 컨트롤러는 각 I/O device마다 붙어있다. 해당 컨트롤러도 작업 공간이 필요한데 이것을 로컬버퍼라고 한다
- 로컬버퍼 : 각 입출력 장치의 컨트롤러가 입출력된 데이터를 임시로 저장하는 작은 메모리
  - 디스크나 키보드 등에서 데이터를 읽어오는 경우
    - 컨트롤러가 장치로부터 데이터를 받아 로컬버퍼에 저장한다
    - 컨트롤러가 CPU의 서비스가 필요할 때 CPU에게 인터럽트 신호 발생시킨다(인터럽트 라인이라는 통로 이용)
- 프로그램이 디스크의 데이터 요청 -> 디스크 컨트롤러가 로컬버퍼로 데이터 읽어서 가져옴 -> 컨트롤러가 CPU에게 인터럽트 발생시킴 -> CPU는 인터럽트를 감지하고 관련 업무 수행

### 인터럽트의 일반적 기능
- 부팅이 끝나고 나면 운영체제는 메모리에 상주한다. 그리고 사건(event)를 기다리며 대기하는 상태이다
- 운영체제 커널에는 인터럽트가 들어왔을 때 해야 할 일이 다 프로그래밍되어 그 코드가 보관되어 있음
- 인터럽트에는 하드웨어 인터럽트, 소프트웨어 인터럽트가 있다
  - 하드웨어 인터럽트 : 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅
    - 만약 우리가 마우스를 움직이면 전기 신호가 발생하고 CPU의 인터럽트 라인으로 연결되고 CPU는 마우스의 event를 인식한다. 그러면 CPU는 현재 하는 일을 중지하고 OS안에 있는 마우스 인터럽트 서비스 루틴(ISR)으로 이동한다. 여기에는 마우스를 움직이면 커서를 옮기는 루틴이 들어있다. 따라서 우리가 마우스를 움직이면 커서가 움직이게 된다. 키보드의 경우도 우리가 어떤 키를 누르면 전기신호가 전달되고 CPU가 OS의 키보드 인터럽트 루틴을 실행시켜서 결국 키보드를 누르면 그 값이 입력되는 것이다
  - 소프트웨어 인터럽트 : 소프트웨어가 인터럽트 라인을 세팅
    - int, swi 명령어가 입력되면 인터럽트가 작용되어 OS내의 특정 코드가 실행(ISR)된다. ISR 종료 후 사용자 프로그램으로 돌아간다.
- 인터럽트 벡터 : 인터럽트 종류마다 번호를 정해놓은 자료구조. 여기서 번호는 해야할일이 적힌 코드의 위치를 가리킴
- 인터럽트 처리루틴, 인터럽트 핸들러 : 실제 처리할 코드가 정의된 곳
- 보통 인터럽트라하면 하드웨어 인터럽트를 말한다. 그래서 소프트웨어 인터럽트를 구분하기 위해 트랩(trap)이라는 용어로 주로 불린다
  - 소프트웨어 인터럽트의 예
  - 예외상황(exception)
    - 0으로 나누거나, 자신의 메모리 바깥에 접근하려고 할 때 이에 대한 처리를 위해 발생시키는 인터럽트. OS안에 0으로 나눌 때의 ISR이 들어 있고 여기에서는 강제로 종료시키도록 하고 있다. 이런 내부 인터럽트에 의해 OS안에 ISR이 동작한다. 사용자가 갑자기 하드 디스크를 읽으려고 하면, OS안에 하드 디스크를 읽는 ISR이 실행된다. ISR이 작업을 마치면 OS는 대기상태가 되고 작업은 다시 사용자 프로그램으로 돌아오게 된다.
  - 시스템 콜(system call)
    - 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법
    - 사용자 프로그램이 CPU를 사용하고 싶다고 CPU를 제어하는 코드를 다 짤 수 없어서 인터럽트 라인 세팅을 통해 CPU 제어권을 넘겨 실행하게 한다
    - 사용자는 이미 존재하는 커널의 코드를 호출해서 처리한다
  - 시스템 콜이나 예외상황은 모두 사용자 프로세스로부터 CPU의 제어권이 운영체제에 이양되어 처리되는데, 이 과정에서 프로그램 코드가 직접 인터럽트 라인을 세팅하는 명령을 실행하여 인터럽트를 발생시킨 후 제어권이 넘어가게 되므로 이들도 넓은 의미에서 인터럽트의 범주에 포함시킨다

인터럽트 당한 시점의 레지스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다

- 인터럽트 벡터 : 해당 인터럽트 처리 루틴 주소를 가지고 있음
- 인터럽트 처리 루틴(ISR) : 해당 인터럽트를 처리하는 커널 함수

### 인터럽트 핸들링
- 인터럽트 핸들링 : 인터럽트가 발생한 경우 처리해야 할 일의 절차
- 인터럽트가 발생되면 일단 현재 상태를 저장
  - 실행 중인 명령의 메모리 주소를 포함해 몇 가지 부가적인 정보(=현재 상태)를 저장
  - CPU는 명령이 실행될 때 레지스터(CPU 내부에 있는 임시 기억장치)의 데이터를 읽고 쓰면서 작업하는데 인터럽트를 처리하면 이 명령어가 다 사라지기 때문에 PCB 사용
- PCB(Process Control Block, 프로세스 제어블록)
  - 현재 시스템 내에서 실행되는 프로그램들을 관리하기 위해 운영체제 내에 있는 자료구조
  - PCB는 각각의 프로그램마다 하나씩 존재하며 해당 프로그램의 어느 부분이 실행중이었는지 저장
  - 저장 되는 값들 : 프로그램이 실행 중이던 코드의 메모리 주소와 레지스터 값, 하드웨어 상태 등
- 인터럽트가 발생했을때 PCB의 역할
  - 프로그램이 실행되던 중 인터럽트가 발생하면 그 프로그램의 상태는 PC에 저장한 후 CPU의 제어권이 인터럽트 처리루틴으로 넘어간다
  - 인터럽트 처리가 끝나면 PCB로부터 저장된 상태를 CPU로 복원해 직전 위치부터 실행한다
- 오늘날 운영체제는 인터럽트가 발생할 때에만 실행된다
  - CPU가 온전히 사용자 프로그램에 의해서만 사용되다가 인터럽트가 발생해야 운영체제가 CPU를 사용한다
  - 사용자 프로그램이 원하는 만큼 CPU르 점유할 수 있게 된다

### 입출력 구조
- 입출력 : 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고받는 것
- 동기식 입출력 : 입출력 작업이 완료될때까지 기다렸다가 후속작업을 하는 방식
  - CPU는 동기식 입출력이 끝날때까지 아무 작업도 못하고 기다려야돼서 자원의 낭비가 발생함
  - 이때 해당 프로그램에는 CPU를 할당하지 않고 다른 프로그램에 CPU를 할당해서 자원의 낭비를 막는데 할당되지 못하는 상태를 봉쇄 상태(blocked state)라고 한다
- 정리 : 프로그램 A에서 CPU가 작업중 -> 디스크에서 데이터를 불러와야 함 -> 인터럽트 발생 -> CPU는 프로그램 A에서 손을 떼고 다른 프로그램을 처리하게 된다 -> 프로그램 A에서 필요한 데이터를 다 불러올때까지 프로그램 A는 봉쇄 상태(blocked state)가 된다.
- 비동기식 입출력 : 입출력 작업이 완료될때까지 기다리지 않고서도 할수 있는일들을 하는것

### DMA(Direct Memory Access)
- 원칙적으로 메모리는 CPU에 의해서만 접근 가능
- CPU는 로컬버퍼와 메모리 사이에 데이터를 옮긴다
- 입출력장치가 메모리 접근을 원할 때마다 CPU에게 인터럽트를 발생시키면 CPU가 할일이 너무 많아진다
- 이를 해결해 주는 장치가 DMA(Direct Memory Access)이다
  - DMA는 일종의 컨트롤러
  - DMA가 로컬버퍼에서 메모리로 읽어오는 일을 대행함
  - DMA는 바이트 단위가 아닌 블록단위로 일을 함
![dma](https://user-images.githubusercontent.com/67304980/128346566-19e6604f-c000-4ecc-b8ec-6256b4d5adc3.JPG)
  - CPU의 개입 없이 I/O 장치와 기억장치 사이의 데이터를 전송

### 저장장치의 구조
- 저장장치 = 주기억장치(메모리) + 보조기억장치
- 보조기억장치의 용도
  - 파일 시스템용
    - 전원이 나가도 유지되어야 하는 정보 저장용
  - 스왑 영역용
    - 스왑 영역 : 메모리의 연장 공간
    - 메모리는 비싸기 때문에 메모리가 부족한 상황이 흔하게 발생해서 당장 필요하지 않은 부분을 스왑 영역에 내려놓게 된다 -> 스왑 아웃이라고 함

### 저장장치의 계층 구조
![저장장치계층](https://user-images.githubusercontent.com/67304980/128347012-e376d8cb-90d1-449c-afc6-59ac93a499c7.JPG)
- 위로 갈수록 비싸고 빠르다
- 정말 필요한 정보일수록 위로 가고 그렇지 않은 부분은 밑에 보관하는 식으로 자원을 효율적이고 빠르게 사용한다
- 캐싱 기법 : 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적 기법
  - 느린 저장장치에 있는 내용 중 당장 사용되거나 빈번히 사용된 정보를 빠른 저장장치에 선별적으로 저장함으로써 두 저장장치 사이의 속도를 완충시킨다
  - 예를 들어 프로그램의 코드 중에는 많은 횟수 동안 반복되는 코드와, 한번 수행되고 끝나는 부분이 있을 수 있다. 이러한 경우 반복되는 코드를 빠른 저장장치에 올려놓으면 적은 저장공간만으로도 전체 시스템의 평균적인 성능을 향상시킬 수 있다. 이러한 캐싱 기법을 컴퓨터 시스템 내의 다양한 저장장치 계층에서 활용함으로써 적은 용량의 상위 저장장치만으로도 대부분의 경우 빠른 수행 속도의 성능을 얻어낼 수 있게 된다

### 하드웨어의 보안
- 운영체제는 멀티 프로그래밍 환경으로 여러 프로그램을 실행할 수 있다
- 각 프로그램이 다른 프로그램의 실행을 방해하거나 충돌을 일으킬 수 있다
- 이를 막기 위해 운영체제는 커널 모드(kernel mode, system mode)와 사용자 모드(user mode)가 있다

커널모드
- 중요한 정보에 접근하여 연산하는 경우는 커널모드에서만 실행된다
- 모든 종류의 명령을 다 실행할 수 있다
- 하지만 사용자 프로그램이 CPU를 갖고 있는 동안은 운영체제가 이를 감시할 수가 없다(CPU를 차지하고 있지 않기 때문)
- 이 상황을 하드웨어적으로 해결 -> 모드 비트
  - mode bit = 0 -> 커널 모드
  - mode bit = 1 -> 사용자 모드
- 운영체제에서 사용자 프로그램으로 CPU의 권한을 넘겨줄 때 mode bit를 1로 설정해서 넘겨준다. CPU는 보안과 관련된 명령을 수행하기 전에는 항상 모드비트를 조사해 그 값이 0으로 세팅된 경우에만 실행한다
- 파일 입출력의 경우 사용자가 다른 사용자의 파일에 접근하면 안된다. 그래서 커널모드로만 입출력을 할 수 있다. 운영체제가 입출력을 실행하기 전에 올바른 입출력인지 판단하고 실행하기 때문에 보안 유지 가능하다.
    
이를 이중 모드라고도 한다. 일반 프로그램 실행 과정을 살펴보자. 첫째로 프로그램이 메모리에 적재된다. 이때는 사용자 모드인데 사용자가 키보드, 마우스 작업을 하면 시스템모드로 바뀌고 ISR이 실행된다. 그 작업이 마무리 되면 다시 사용자 모드로 전환된다. 이후 또 다시 모니터, 디스크, 프린터 등의 작업이 있다면 시스템 모드로 바뀌고 ISR이 실행된다. 작업이 종료되면 다시 사용자 모드로 전환된다. 이러한 이중모드는 "보호"와 관련이 있다.
- 입출력장치 보호
  - 예를 들어 한 사람이 프린터를 사용하고 있는데 다른 사용자가 프린터에 reset신호를 보낸다던지, 나도 사용하겠다고 신호를 보낸다면 안된다. 혹은 하드디스크에 여러 사람의 파일이 들어 있는데, 특정 사용자가 다른 사용자의 파일을 보면 안된다. 이처럼 입출력장치들은 보호를 받아야 한다.

  - 해결법 : 입출력 명령을 특권명령으로 지정한다(in,out명령어). 즉 입출력을 하려면 운영체제에게 요청(software interrupt)하고(system mode로 전환), 운영체제가 입출력을 대행해주고 마치고 다시 user mode로 돌아온다. 만약 올바른 요청이 아니라면 운영체제가 거부할 수 있다. (모든 애플리케이션은 하드웨어에 직접 접근 불가하다. 하드웨어를 os가 감싸고 있기 때문에 애플리케이션은 os에 부탁을 하여 하드웨어에 접근할 수 있다.)

- 메모리 보호
  - 다른 사용자의 메모리나 운영체제 영역 메모리에 접근할 수 있는 문제가 발생할 수 있다. 이는 다른 사용자 정보/프로그램/운영체제에 대한 해킹이 발생할 수 있다. 그래서 MMU(Memory Management Unit)을 두어 다른 메모리 영역의 침범을 감시하도록 한다. MMU설정은 특권명령으로 운영체제만 바꿀 수 있다

- CPU 보호
  - while(n=1)... -> c 프로그램에서 이 코드는 무한루프를 돈다. 따라서 다른 사용자의 프로그램은 실행이 불가능하게 된다. 이러한 상황을 해결하는 방법은 Timer를 두어 일정 시간 경과 시 타이머 인터럽트를 걸어 OS안에 ISR가 실행되도록 한다. ISR에는 오랜 기간 특정 프로그램에 묶여있다면 다른 프로그램으로 강제 전환되도록 하는 코드가 실행된다.


### I/O의 수행

#### 사용자 프로그램은 어떻게 I/O를 수행할까?

사용자 프로그램은 I/O 작업을 수행할 때 OS의 함수를 호출해야 하는데 메모리상의 OS 주소로 이동할 수 없다(레지스터에 프로그램 카운터가 운영체제의 주소로 가야하는데 모드 비트 1으므로 불가능). 모드 비트가 1인 상태이기 때문에 메모리 참조가 불가능하고 오직 사용자 프로그램 메모리 영역만 사용할 수 있을 뿐이다. 그러면 어떻게 운영체제의 함수를 호출할 수 있을까? 사용자 프로그램과 CPU사이의 인터럽트 라인이 생성되고 사용자 프로그램이 인터럽트를 거는 것이다. 인터럽트가 들어왔으므로 모드비트가 0으로 바뀌고 제어권이 운영체제로 넘어갔다. 그 다음 I/O작업이 수행될 수 있다. 이를 시스템 콜이라고 한다. 이는 소프트웨어 인터럽트(트랩)에 포함된다. 소프트웨어 인터럽트는 예외(Exception)와 시스템 콜 두 가지가 있다. 그러고 나서 OS는 device 컨트롤러에게 일을 시키고 작업이 완료되면 하드웨어 인터럽트가 발생한다. 정리하면 I/O는 소프트웨어 인터럽트와 하드웨어 인터럽트 둘 다 발생한다.

### 동기식 입출력과 비동기식 입출력
- 동기식 입출력(synchronous I/O)
  - I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램으로 넘어감
  - 구현 방법 1
    - I/O가 끝날 때까지 CPU를 낭비시킴
    - 매 시점 하나의 I/O만 일어날 수 있음
  - 구현 방법 2
    - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
    - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
    - 다른 프로그램에게 CPU를 줌

- 비동기식 입출력(asynchronous I/O)
  - I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감
 
- 두 경우 모두 I/O의 완료는 인터럽트로 알려줌

![image](https://user-images.githubusercontent.com/67304980/140162288-b35bfc8d-ed32-42ab-b379-ebd6c7c1fe4e.png)

### 프로그램의 실행(메모리 load)

![image](https://user-images.githubusercontent.com/67304980/140165573-9b60b71c-0076-43ef-a15e-41ffe2527994.png)

프로그램을 실행시키면 독자적인 메모리 주소 공간(가상 메모리 : 각 프로그램마다 독자적으로 갖고 있는 메모리 공간)이 만들어진다. 그것을 물리적 메모리에 올려야 하는데 다 올리지 않고 필요한 부분만 올리고 그렇지 않은 부분은 Swap area(이것도 하드디스크에 있다. 메모리 연장공간으로 사용하는 것이다)에 내려놓는다. 실제 메모리에 올라갈 때는 주소가 변환되어 올라간다.

#### 커널 주소 공간의 내용
![image](https://user-images.githubusercontent.com/67304980/140166357-e4c58a59-5c3c-43b4-ae07-765f5176e976.png)


### 사용자 프로그램이 사용하는 함수
- 사용자 정의 함수(사용자 프로그램의 stack data code 영역 중 code 영역에 있음)
  - 자신의 프로그램에서 정의한 함수
- 라이브러리 함수
  - 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
  - 자신의 프로그램의 실행 파일에 포함되어 있다
- 커널 함수(운영체제의 stack data code 영역 중 code 영역에 있음)
  - 운영체제 프로그램의 함수
  - 커널 함수의 호출 = 시스템 콜



















