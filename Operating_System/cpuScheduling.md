### CPU 스케줄링

> CPU가 하나의 프로세스 작업이 끝나면 다음 프로세스 작업을 수행해야 한다. 이때 어떤 프로세스를 다음에 처리할
> 지 선택하는 알고리즘을 CPU Scheduling 알고리즘이라고 한다. 따라서 상황에 맞게 CPU를 어떤 프로세스에 배정
> 하여 효율적으로 처리하는지가 관건이라고 할 수 있다

#### Preemptive VS Non-Preemptive
1. Preemptive(선점)
- 프로세스가 CPU를 점유하고 있는 동안 I/O나 인터럽트가 발생하지 않았음에도 다른 프로세스가 해당 CPU를 강제로 점유할 수 있다
- 즉, 프로세스가 정상적으로 수행중인 동안 다른 프로세스가 CPU를 강제로 점유하여 실행할 수 있다

2. Non-Preemptive(비선점)
- 한 프로세스가 CPU를 점유했다면 I/O나 인터럽트 발생 또는 프로세스가 종료될 때까지 다른 프로세스가 CPU를 점유하지 못하는 것이다

#### 선점형 스케줄링
1. SRT(Shortest Remaining Time) 스케줄링
- 짧은 시간 순서대로 프로세스를 수행한다
- 현재 CPU에서 실행 중인 프로세스의 남은 CPU 버스트 시간보다 더 짧은 CPU 버스트 시간을 가지는 프로세스가 도착하면 CPU가 선점된다

2. Round Robin 스케줄링
- 시분할 시스템의 성질을 활용한 방법
- 일정 시간을 정하여 하나의 프로세스가 이 시간동안 수행하고 다시 대기 상태로 돌아간다
- 그리고 다음 프로세스 역시 같은 시간동안 수행한 후, 대기한다. 이러한 작업을 모든 프로세스가 돌아가면서 진행하며, 마지막 프로세스가 끝나면 다시 처음 프로세스로 돌아와서 작업을 반복한다
- 일정 시간을 Time Quantum(Time Slice)라고 부른다. 일반적으로 10 - 100msec 사이의 범위를 갖는다
- 한 프로세스가 종료되기 전에 time quantum이 끝나면 다른 프로세스에게 CPU를 넘겨주기 때문에 선점형 스케줄링의 대표적인 예시다

3. Multi-level Queue 스케줄링
- 프로세스를 그룹으로 나누어, 각 그룹에 따라 Ready Queue(준비 큐)를 여러 개 두며, 각 큐마다 다른 규칙을 지정할 수도 있다(ex. 우선순위, CPU 시간 등)
- 즉, 준비 큐를 여러 개로 분할해 관리하는 스케줄링 방법이다
- 프로세스들이 CPU를 기다리기 위해 한 줄로 서는 게 아니라 여러 줄로 선다
![image](https://user-images.githubusercontent.com/67304980/130614952-00b5b395-af65-456b-8277-78402de85fc8.png)
4. Multi-level feedback Queue 스케줄링
- 기본 개념은 Multi-level Queue와 동일하나, 프로세스가 하나의 큐에서 다른 큐로 이동 가능하다는 점이 다르다
![image](https://user-images.githubusercontent.com/67304980/130615043-5ae717a7-7a4c-4fda-bbc1-e057d05aaf4c.png)
- 위 그림에서 모든 프로세스는 가장 위의 큐에서 CPU의 점유를 대기한다. 이 상태로 진행하다가 이 큐에서 기다리는 시간이 너무 오래 걸린다면 아래의 큐로 프로세스를 옮긴다. 이와 같은 방식으로 대기 시간을 조정할 수 있다
- 만약, 우선순위 순으로 큐를 사용하는 상황에서 우선순위가 낮은 아래의 큐에 있는 프로세스에서 starvation 상태가 발생하면 이를 우선순위가 높은 위의 큐로 옮길 수도 있다
- 대부분의 상용 운영체제는 여러 개의 큐를 사용하고 각 큐마다 다른 스케줄링 방식을 사용한다. 프로세스의 성격에 맞는 스케줄링 방식을 사용하여 최대한 효율을 높일 수 있는 방법을 선택한다

#### 비선점형 스케줄링
1. FCFS(First Come First Served)
- 준비 큐에 먼저 도착한 프로세스가 먼저 CPU를 점유하는 방식이다
- CPU를 할당받으면 CPU 버스트가 완료될 때까지 CPU를 반환하지 않으며, 할당되었던 CPU가 반환될 때만 스케줄링이 이루어진다
- Simple & Fair
- 단점 : Convoy Effect 발생 : 소요 시간이 긴 프로세스가 짧은 프로세스보다 먼저 도착해서 뒤에 프로세스들이 오래 기다려야 하는 현상
![image](https://user-images.githubusercontent.com/67304980/130628613-545c67b4-9fde-41a4-8405-114025ad1dac.png)
  > 평균 대기 시간을 구해보자. p1은 0msec에 시작된다. p2는 24msec을 대기하고 시작된다. p3는 27msec을 대기하고 시작된다. 0,24,27의 평균은 17이다. 만약 p2,p3,p1순서로 시작되었다면 대기시간은 0,3,6이며 평균은 3이다. 따라서 대기시간을 척도로 본다면 FCFS방식은 좋진 않다. 만약 첫번째 프로세스가 실행시간이 길고 뒤이은 프로세스가 실행순서가 짧다면 뒤의 프로세스들은 첫번째 프로세스를 따라다니는 형세가 되는데 이를 호위효과라고 한다. FCFS는 Nonpreemtive scheduling이다. 

2. SJF(Shortest-Job-First)
- 다른 프로세스가 먼저 도착했더라도 CPU 버스트가 짧은 프로세스에게 CPU를 먼저 할당하는 방식이다
- 선점, 비선점 모두 가능

- Shortest-Job_First(1)
  - Provably optimal -> 대기시간 줄이는 측면에서는 가장 좋은 방법이다
  - Not realistic; prediction may be needed -> 비현실적(실제로는 프로세스가 cpu시간을 얼마나 사용할지는 해봐야 안다). 프로세스 시간은 예측된 후에 측정이 가능하다.
![image](https://user-images.githubusercontent.com/67304980/130629233-330bc161-460d-4338-9fd0-74c2070e27fc.png)
   > 실행시간이 짧은 순서대로 정렬하면 p4 - p1 - p3 - p2 순이다. 그러면 각 프로세스의 대기시간의 합은 0+3+9+16 = 28이다. 이걸 4로 나누면 평균적으로 7msec을 기다린 것이다. 만약 FCFS 방식으로 했다면 평균 10.25msec이 나온다.

- Shortest-Job_First(2)
  - Preemptive or Nonpreemtive -> Shortest-Remaining- Time - First(최소잔여시간 우선)
![image](https://user-images.githubusercontent.com/67304980/130629389-533f0b6e-99da-4068-bc5a-4f8ccac39174.png)
  > Nonpreemptive로 할 경우 시간0에서 p1밖에 없으므로 p1을 먼저 실행한다. 그러면 시간8이 되는데 이때 p2,p3,p4다 들어와있다. 이때 가장 실행시간 짧은 순으로 p2 - p4 - p3순으로 실행한다. 평균 대기시간은 {0+(8-1)+(17-2)+(12-3)}/4는 (0+7+15+9)/4 = 7.75가 나온다. Preemptive로 할 경우 시간0에서 p1밖에 없으므로 p1을 먼저 실행한다. 시간1에서 p2가 들어오는데 실행시간이 p2가 짧으므로 p2로 스위칭된다. 시간2에서 p3가 들어오고 실행시간을 비교하면 p2가 제일 짧으므로 그대로 진행된다. 시간3에서 p4가 들어오고 실행시간을 비교하여 p2가 그대로 진행된다. p2가 종료되면 p1,p3,p4인데 p4가 먼저 돌고 그 다음 p1, 마지막으로 p3가 돈다. 평균 대기시간은 {9+(1-1)+(17-2)+(5-3)}/4 = 26/4 = 6.5가 나온다.

3. Priority
- 우선순위가 높은 프로세스가 먼저 선택되는 스케줄링 알고리즘이다
- 우선순위는 정수값으로 나타내며, 작은 값이 우선순위가 높다(Unix, Linux 기준)
- 선점, 비선점 모두 가능하다
![image](https://user-images.githubusercontent.com/67304980/130629690-b6387082-4a46-449e-94bd-4091ef035ce5.png)
  > 우선순위가 높은 순으로 진행한다. p2-p5-p1-p3-p4 순으로 진행한다. 평균 대기시간을 계산해보면(0+1+6+16+18)/5 = 8.2가 나온다.
- Priority(우선순위)
  - 내부요소 : 시간제한, 메모리 요구량, i/o와 cpu시간 등
  - 외부요소 : 돈 많이 낸 쪽(보통 유료 컴퓨터의 경우), 정치적 요소(학생의 과제 업무보다 입시 업무의 우선순위 높임) 
- Preemptive or Nonpreemptive
- Problem
  - 기아 : 만약 계속 기다리는 프로세스가 있는데 계속 큐에 프로세스가 들어온다. 만약 들어오는 프로세스들이 다 우선순위가 높다면 영영 해당 프로세스는 처리될 수 없다.
  - 해결책 : aging이다. 레디 큐에서 실행 안되고 오래 머문다면 해당 프로세스의 우선순위를 점진적으로 높여주는 것.
 
























