#### 인터럽트(Interrupt)

정의

프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것

지금 수행중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야 한다


- 하드웨어 장치가 CPU에게 어떤 사실을 알려주거나 CPU의 서비스를 요청해야 할 경우, CPU 내에 있는 인터럽트 라인을
세팅하여 인터럽트를 발생시킨다(프로그램이 명령을 수행하기 위해서는 CPU를 할당받아야 함)
- CPU는 매번 프로그램 카운터가 가리고 있는 곳의 명령을 수행한 뒤, 다음 명령을 수행하기 직전에 인터럽트 라인이
세팅되었는지 체크한다
- 이를 통해 인터럽트가 발생했으면 CPU는 현재 수행 중이던 프로세스를 멈추고 운영체제의 인터럽트 처리 루틴으로
이동하여 인터럽트 처리를 수행한다

##### 인터럽트의 종류
1. 하드웨어 인터럽트(일반적인 인터럽트)
    - 하드웨어 컨트롤러가 CPU의 서비스를 요청하기 위해 발생시키는 인터럽트
    - CPU의 하드웨어 신호에 의해 발생
![image](https://user-images.githubusercontent.com/67304980/130320788-01d36973-1834-4dc6-a8ff-0b88d628d1a8.png)

2. 소프트웨어 인터럽트(Trap:트랩)
    - 명령어의 수행에 의해 발생
    1. 예외 상황(Exception)
        - 프로그램이 허용되지 않은 연산을 수행하려고 할 때, 자동적으로 발생한다. 운영체제는 예외 상황이 발생했을 때, CPU의 제어권을 획득해 이 상황에 대한 조치를 취한다.
        - ex) 0으로 나누는 연산, 자신의 주소 공간을 넘어서는 메모리 참조 등
        - 예외 상황에 대한 처리 루틴을 자신의 코드 영역에 가지고 있음
    2. 시스템 콜(System Call)
        - 사용자 프로세스가 운영체제의 서비스를 요청하기 위해 커널의 함수를 호출하는 것이다
        - 사용자 프로세스가 직접 특권 명령을 수행할 수 없으므로 특권 명령을 수행하려 할 때, 시스템 콜을 사용한다.
![image](https://user-images.githubusercontent.com/67304980/130320852-b8e99ac7-5ec0-486d-bb8f-33ff63214f94.png)

###### 소프트웨어 인터럽트 발생 과정
시스템 콜이나 예외 상황은 모두 사용자 프로세스로부터 CPU의 제어권이 운영 체제에게 이양되어 처리되는데 이 과정에 인터럽트 라인을 세팅하여 인터럽트를 발생시킨 후 제어권이 넘어가게 되므로 이들도 넓은 의미에서는 인터럽트의 범주에 포함시킨다. 단지 인터럽트를 발생시키는 주체가 하드웨어 장치가 아닌 스프트웨어이므로 이들을 소프트웨어 인터럽트라고 부른다. 프로그램 처리 중 명령의 요청에 의해 발생한 것(SVC 인터럽트)이다. 즉 사용자가 프로그램을 실행시킬 때 발생하고 소프트웨어 이용 중에 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행된다.

###### 인터럽트 발생 처리 과정
A 프로그램이 CPU를 할당받고 명령을 수행하고 있는데 인터럽트가 발생하면 A는 현재 수행중인 명령의 위치를 저장해놓는다. 그 후 운영 체제 내부 코드인 인터럽트 처리 루틴으로 넘어가서 인터럽트 처리를 하고 다시 돌아와 A의 이전 작업 지점부터 수행을 계속 이어나가게 된다.

Q. 그렇다면 인터럽트가 발생했을 때 수행중이던 프로세스의 정보는 어디에 저장될까?
A. 진행 중이던 A 프로세스의 정보는 프로세스 제어 블록(PCB : Process Control Block)에 저장한다. 그리고 인터럽트 처리를 모두 마치면 프로그램 A의 PCB에 저장된 주소를 복원시켜 원래 수행하던 일을 재개하게 된다
- 인터럽트 벡터(Interrupt Vector)
    - 여러가지 인터럽트에 대해 해당 인터럽트 발생 시 처리해야 할 루틴의 주소를 보관하고 있는 테이블
    - 일종의 함수를 가리키는 포인터
- 인터럽트 핸들러(Interrupt Handler)
    - 실제 인터럽트를 처리하기 위한 루틴으로 인터럽트 서비스 루틴이라고도 한다
    - 운영체제 코드 부분에는 각종 인터럽트별로 처리해야 할 내용이 이미 프로그램되어 있으며, 이 부분을 인터럽트 서비스 루틴 또는 인터럽트 핸들러라고 한다.

예를 들어, 입출력 관련 인터럽트가 발생한 경우, CPU는 인터럽트 라인을 통해 발생한 인터럽트를 확인한다. 인터럽트 벡터를 통해 해당 인터럽트 밸생시 처리해야 할 루틴의 메모리 주소를 알아낸다. 주소를 통해 실제 수행되어야 할 코드가 담겨있는 루틴을 찾아가 상황에 맞는 처리를 진행한다.

다른 설명을 살펴보자

주 프로그램이 실행되다가 인터럽트가 발생했다.

현재 수행 중인 프로그램을 멈추고, 상태 레지스터와 PC 등을 스택에 잠시 저장한 뒤에 인터럽트 서비스 루틴으로 간다. (잠시 저장하는 이유는, 인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아와야 하기 때문이다)

만약 인터럽트 기능이 없었다면, 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 계속 체크를 해야 한다(폴링)
폴링을 하는 시간에는 원래 하던 일에 집중할 수가 없게 되어 많은 기능을 제대로 수행하지 못하는 단점이 있었다

즉, 컨트롤러가 입력을 받아들이는 방법(우선순위 판별방법)에는 두가지가 있다
- 폴링 방식
    - 사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아내는 방식
    - 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다(하드웨어에 비해 속도 느림)
- 인터럽트 방식
    - MCU(Micro Controller Unit) 자체가 하드웨어적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식
        - Daisy Chain(연속적으로 연결되어 있는 하드웨어 장치들의 구성)
        - 병렬 우선순위 부여

인터럽트 방식은 하드웨어로 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능하다. 따라서 실시간 대응이 필요할 때는 필수적인 기능이다

즉, 인터럽트는 발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법이다.







